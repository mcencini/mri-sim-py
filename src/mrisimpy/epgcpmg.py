#!/usr/bin/python

# EPG CPMG simulation code, based off of Matlab scripts from Brian Hargreaves <bah@stanford.edu>
# 2015 Jonathan Tamir <jtamir@eecs.berkeley.edu>

import numpy as np
from warnings import warn

def rf(FpFmZ, alpha):
    "Same as rf2, but only returns FpFmZ"""
    return rf2(FpFmZ, alpha)[0]

def rf2(FpFmZ, alpha):
    """ Propagate EPG states through an RF rotation of 
    alpha (radians). Assumes CPMG condition, i.e.
    magnetization lies on the real x axis.

    INPUT:
        FpFmZ = 3xN vector of F+, F- and Z states.
        alpha = RF pulse flip angle in radians

    OUTPUT:
        FpFmZ = Updated FpFmZ state.
        RR = RF rotation matrix (3x3).

    """

    # -- From Weigel at al, JMRI 41(2015)266-295, Eq. 21.

    
    if abs(alpha) > 2 * np.pi:
        warn('rf2: Flip angle should be in radians! alpha=%f' % alpha)

    cosa2 = np.cos(alpha/2.)**2
    sina2 = np.sin(alpha/2.)**2

    cosa = np.cos(alpha)
    sina = np.sin(alpha)

    RR = np.array([ [cosa2, sina2, sina],
                    [sina2, cosa2, -sina],
                    [-0.5 * sina, 0.5 * sina, cosa] ])


    FpFmZ = np.dot(RR, FpFmZ)

    return FpFmZ, RR

def rf_ex(FpFmZ, alpha):
    "Same as rf2_ex, but only returns FpFmZ"""
    return rf2_ex(FpFmZ, alpha)[0]

def rf2_ex(FpFmZ, alpha):
    """ Propagate EPG states through an RF excitation of 
    alpha (radians) along the y direction, i.e. phase of pi/2.

    INPUT:
        FpFmZ = 3xN vector of F+, F- and Z states.
        alpha = RF pulse flip angle in radians

    OUTPUT:
        FpFmZ = Updated FpFmZ state.
        RR = RF rotation matrix (3x3).

    """

    try:
        alpha = alpha[0]
    except:
        pass


    if abs(alpha) > 2 * np.pi:
        warn('rf2_ex: Flip angle should be in radians! alpha=%f' % alpha)

    cosa2 = np.cos(alpha/2.)**2
    sina2 = np.sin(alpha/2.)**2

    cosa = np.cos(alpha)
    sina = np.sin(alpha)

    RR = np.array([ [cosa2, -sina2, sina],
                    [-sina2, cosa2, sina],
                    [-0.5 * sina, -0.5 * sina, cosa] ])

    FpFmZ = np.dot(RR, FpFmZ)

    return FpFmZ, RR



def rf_prime(FpFmZ, alpha):
    """Same as rf_prime2, but only returns FpFmZ"""
    return rf_prime2(FpFmZ, alpha)[0]

def rf_prime2(FpFmZ, alpha):
    """ Compute the gradient of the RF rotation operator, where
    alpha (radians) is the RF rotation. Assumes CPMG condition, i.e.
    magnetization lies on the real x axis.

    INPUT:
        FpFmZ = 3xN vector of F+, F- and Z states.
        alpha = RF pulse flip angle in radians

    OUTPUT:
        FpFmZ = Derivative of FpFmZ state w.r.t. alpha
        RR = Derivative of RF rotation matrix (3x3) w.r.t. alpha

    """

    if abs(alpha) > 2 * np.pi:
        warn('rf_prime2: Flip angle should be in radians! alpha=%f' % alpha)

    RR = np.array([ [-np.cos(alpha/2.) * np.sin(alpha/2.), np.cos(alpha/2.) * np.sin(alpha/2.), np.cos(alpha)],
                    [np.cos(alpha/2.) * np.sin(alpha/2.), -np.cos(alpha/2.) * np.sin(alpha/2.), -np.cos(alpha)],
                    [-0.5 * np.cos(alpha), 0.5 * np.cos(alpha), -np.sin(alpha)] ])

    FpFmZ = np.dot(RR, FpFmZ)

    return FpFmZ, RR


def rf_B1_prime(FpFmZ, alpha, B1):
    """Same as rf_B1_prime2, but only returns FpFmZ"""
    return rf_B1_prime2(FpFmZ, alpha, B1)[0]

def rf_B1_prime2(FpFmZ, alpha, B1):
    """ Compute the gradient of B1 inhomogeneity w.r.t. RF refocusing operator, where
    alpha (radians) is the RF rotation and B1 is the B1 homogeneity (0, 2).
    Assumes CPMG condition, i.e. magnetization lies on the real x axis.

    INPUT:
        FpFmZ = 3xN vector of F+, F- and Z states.
        alpha = RF pulse flip angle in radians
        B1 = B1 Homogeneity, where 1. is homogeneous

    OUTPUT:
        FpFmZ = Derivative of FpFmZ state w.r.t. alpha
        RR = Derivative of RF rotation matrix (3x3) w.r.t. B1

    """

    if abs(alpha) > 2 * np.pi:
        warn('rf_B1_prime2: Flip angle should be in radians! alpha=%f' % alpha)

    if B1 < 0 or B1 > 2:
        warn('rf_B1_prime2: B1 Homogeneity should be a percentage between (0, 2)')

    RR = np.array([ [-alpha*np.cos(B1*alpha/2.) * np.sin(B1*alpha/2.), alpha*np.cos(B1*alpha/2.) * np.sin(B1*alpha/2.), alpha*np.cos(B1*alpha)],
                    [alpha*np.cos(B1*alpha/2.) * np.sin(B1*alpha/2.), -alpha*np.cos(B1*alpha/2.) * np.sin(B1*alpha/2.), -alpha*np.cos(B1*alpha)],
                    [-0.5*alpha*np.cos(B1*alpha), 0.5*alpha*np.cos(B1*alpha), -alpha*np.sin(B1*alpha)] ])

    FpFmZ = np.dot(RR, FpFmZ)

    return FpFmZ, RR


def rf_ex_B1_prime(FpFmZ, alpha, B1):
    """Gradient of B1 inhomogeneity w.r.t. RF excitation operator, where
    alpha (radians) is the RF rotation and B1 is the B1 honogeneity (0, 2).
    Assumes CPMG condition, i.e. RF excitation in the y direction.

    INPUT:
        FpFmZ = 3xN vector of F+, F- and Z states.
        alpha = RF pulse flip angle in radians
        B1 = B1 Homogeneity, where 1. is homogeneous

    OUTPUT:
        FpFmZ = Derivative of FpFmZ state w.r.t. alpha
    """

    if abs(alpha) > 2 * np.pi:
        warn('rf_ex_B1_prime2: Flip angle should be in radians! alpha=%f' % alpha)

    if B1 < 0 or B1 > 2:
        warn('rf_ex_B1_prime: B1 Homogeneity should be a percentage between (0, 2)')

    RR = np.array([ [-alpha*np.cos(B1*alpha/2.) * np.sin(B1*alpha/2.), alpha*np.cos(B1*alpha/2.) * np.sin(B1*alpha/2.), alpha*np.cos(B1*alpha)],
                    [alpha*np.cos(B1*alpha/2.) * np.sin(B1*alpha/2.), -alpha*np.cos(B1*alpha/2.) * np.sin(B1*alpha/2.), alpha*np.cos(B1*alpha)],
                    [-0.5*alpha*np.cos(B1*alpha), -0.5*alpha*np.cos(B1*alpha), -alpha*np.sin(B1*alpha)] ])

    FpFmZ = np.dot(RR, FpFmZ)

    return FpFmZ


def relax_mat(T, T1, T2):
    E2 = np.exp(-T/T2)
    E1 = np.exp(-T/T1)

    EE = np.diag([E2, E2, E1])      # Decay of states due to relaxation alone.

    return EE

def relax_mat_prime_T1(T, T1, T2):
    E1_prime_T1 = T * np.exp(-T/T1) / T1**2
    return np.diag([0, 0, E1_prime_T1])

def relax_mat_prime_T2(T, T1, T2):
    E2_prime_T2 = T * np.exp(-T/T2) / T2**2
    return np.diag([E2_prime_T2, E2_prime_T2, 0])


def relax_prime_T1(FpFmZ, T, T1, T2):
    """returns E'(T1) FpFmZ + E0'(T1)"""
    
    EE_prime_T1 = relax_mat_prime_T1(T, T1, T2)
    
    RR = -EE_prime_T1[2,2]
    
    FpFmZ = np.dot(EE_prime_T1, FpFmZ)
    FpFmZ[2,0] = FpFmZ[2,0] + RR
    
    return FpFmZ

def relax_prime_T2(FpFmZ, T, T1, T2):
    """returns E'(T2) FpFmZ"""
    
    EE_prime_T2 = relax_mat_prime_T2(T, T1, T2)
    FpFmZ = np.dot(EE_prime_T2, FpFmZ)
    
    return FpFmZ


def relax(FpFmZ, T, T1, T2):
    """Same as relax2, but only returns FpFmZ"""
    return relax2(FpFmZ, T, T1, T2)[0]

def relax2(FpFmZ, T, T1, T2):
    """ Propagate EPG states through a period of relaxation over
    an interval T.

    INPUT:
        FpFmZ = 3xN vector of F+, F- and Z states.
        T1, T2 = Relaxation times (same as T)
        T = Time interval (same as T1,T2)

    OUTPUT:
        FpFmZ = updated F+, F- and Z states.
        EE = decay matrix, 3x3 = diag([E2 E2 E1]);

   """

    E2 = np.exp(-T/T2)
    E1 = np.exp(-T/T1)

    EE = np.diag([E2, E2, E1])      # Decay of states due to relaxation alone.
    RR = 1 - E1                     # Mz Recovery, affects only Z0 state, as 
                                    # recovered magnetization is not dephased.


    FpFmZ = np.dot(EE, FpFmZ)       # Apply Relaxation
    FpFmZ[2,0] = FpFmZ[2,0] + RR    # Recovery  

    return FpFmZ, EE



def grad(FpFmZ, noadd=False):
    """Propagate EPG states through a "unit" gradient. Assumes CPMG condition,
    i.e. all states are real-valued.

    INPUT:
        FpFmZ = 3xN vector of F+, F- and Z states.
        noadd = True to NOT add any higher-order states - assume
                that they just go to zero.  Be careful - this
                speeds up simulations, but may compromise accuracy!

    OUTPUT:
        Updated FpFmZ state.

    """

    # Gradient does not affect the Z states.

    if noadd == False:
        FpFmZ = np.hstack((FpFmZ, [[0],[0],[0]]))   # add higher dephased state

    FpFmZ[0,:] = np.roll(FpFmZ[0,:], 1)     # shift Fp states
    FpFmZ[1,:] = np.roll(FpFmZ[1,:], -1)    # shift Fm states
    FpFmZ[1,-1] = 0                         # Zero highest Fm state
    FpFmZ[0,0] = FpFmZ[1,0]                 # Fill in lowest Fp state

    return FpFmZ



def FSE_TE(FpFmZ, alpha, TE, T1, T2, noadd=False, recovery=True):
    """ Propagate EPG states through a full TE, i.e.
    relax -> grad -> rf -> grad -> relax.
    Assumes CPMG condition, i.e. all states are real-valued.

    INPUT:
        FpFmZ = 3xN vector of F+, F- and Z states.
        alpha = RF pulse flip angle in radians
        T1, T2 = Relaxation times (same as TE)
        TE = Echo Time interval (same as T1, T2)
        noadd = True to NOT add any higher-order states - assume
                that they just go to zero.  Be careful - this
                speeds up simulations, but may compromise accuracy!

    OUTPUT:
        FpFmZ = updated F+, F- and Z states.

   """

    EE = relax_mat(TE/2., T1, T2)

    if recovery:
        FpFmZ = relax(FpFmZ, TE/2., T1, T2)
    else:
        FpFmZ = np.dot(EE, FpFmZ)
    FpFmZ = grad(FpFmZ, noadd)
    FpFmZ = rf(FpFmZ, alpha)
    FpFmZ = grad(FpFmZ, noadd)
    if recovery:
        FpFmZ = relax(FpFmZ, TE/2., T1, T2)
    else:
        FpFmZ = np.dot(EE, FpFmZ)

    return FpFmZ


def FSE_TE_prime_alpha(FpFmZ, alpha, TE, T1, T2, noadd=False, recovery=True):
    """ Gradient of EPG over a full TE, w.r.t. flip angle alpha, i.e.
    relax -> grad -> rf_prime -> grad -> relax_hat,
    where rf_prime is the derivative of the RF pulse matrix w.r.t. alpha,
    and relax_hat  is the relaxation without longitudinal recovery
    Assumes CPMG condition, i.e. all states are real-valued.

    INPUT:
        FpFmZ = 3xN vector of F+, F- and Z states.
        alpha = RF pulse flip angle in radians
        T1, T2 = Relaxation times (same as TE)
        TE = Echo Time interval (same as T1, T2)
        noadd = True to NOT add any higher-order states - assume
                that they just go to zero.  Be careful - this
                speeds up simulations, but may compromise accuracy!
        recovery = True to include T1 recovery in the Z0 state.

    OUTPUT:
        FpFmZ = updated F+, F- and Z states.

   """

    FpFmZ, EE = relax2(FpFmZ, TE/2., T1, T2)
    FpFmZ = grad(FpFmZ, noadd)
    FpFmZ = rf_prime(FpFmZ, alpha)
    FpFmZ = grad(FpFmZ, noadd)
    FpFmZ = np.dot(EE, FpFmZ)

    return FpFmZ


def FSE_TE_prime1_T2(FpFmZ, alpha, TE, T1, T2, noadd=False):
    """ Returns E(T2) G R G E'(T2) FpFmZ"""
    
    EE = relax_mat(TE/2., T1, T2)
    EE_prime = relax_mat_prime_T2(TE/2., T1, T2)

    FpFmZ = np.dot(EE_prime, FpFmZ)
    FpFmZ = grad(FpFmZ, noadd)
    FpFmZ = rf(FpFmZ, alpha)
    FpFmZ = grad(FpFmZ, noadd)
    FpFmZ = np.dot(EE, FpFmZ)
    
    return FpFmZ

def FSE_TE_prime2_T2(FpFmZ, alpha, TE, T1, T2, noadd=False):
    """ Returns E'(T2) G R G (E(T2) FpFmZ + E0)"""
    
    EE_prime = relax_mat_prime_T2(TE/2., T1, T2)
    
    FpFmZ = relax(FpFmZ, TE/2., T1, T2)
    FpFmZ = grad(FpFmZ, noadd)
    FpFmZ = rf(FpFmZ, alpha)
    FpFmZ = grad(FpFmZ, noadd)
    FpFmZ = np.dot(EE_prime, FpFmZ)
    
    return FpFmZ

def FSE_TE_prime1_T1(FpFmZ, alpha, TE, T1, T2, noadd=False):
    """ Returns E(T1) G R G (E'(T1) FpFmZ + E0'(T1))"""
    
    EE = relax_mat(TE/2., T1, T2)
    
    FpFmZ = relax_prime_T1(FpFmZ, TE/2., T1, T2) # E'(T1) FpFmZ + E0'(T1)
    FpFmZ = grad(FpFmZ, noadd)
    FpFmZ = rf(FpFmZ, alpha)
    FpFmZ = grad(FpFmZ, noadd)
    FpFmZ = np.dot(EE, FpFmZ)
    
    return FpFmZ

def FSE_TE_prime2_T1(FpFmZ, alpha, TE, T1, T2, noadd=False):
    """ Returns E'(T1) G R G E(T1) FpFmZ + E0'(T1)"""
    
    EE = relax_mat(TE/2., T1, T2)

    FpFmZ = np.dot(EE, FpFmZ) 
    FpFmZ = grad(FpFmZ, noadd)
    FpFmZ = rf(FpFmZ, alpha)
    FpFmZ = grad(FpFmZ, noadd)
    FpFmZ = relax_prime_T1(FpFmZ, TE/2., T1, T2) # E'(T1) FpFmZ + E0'(T1)
    
    return FpFmZ


def FSE_TE_prime_B1(FpFmZ, alpha, TE, T1, T2, B1, noadd=False):
    """ Gradient of EPG over a full TE, w.r.t. B1 homogeneity fraciton B1, i.e.
    relax -> grad -> rf_B1_prime -> grad -> relax_hat,
    where rf_B1_prime is the derivative of the RF pulse matrix w.r.t. B1,
    and relax_hat  is the relaxation without longitudinal recovery
    Assumes CPMG condition, i.e. all states are real-valued.

    INPUT:
        FpFmZ = 3xN vector of F+, F- and Z states.
        alpha = RF pulse flip angle in radians
        T1, T2 = Relaxation times (same as TE)
        TE = Echo Time interval (same as T1, T2)
        B1 = fraction of B1 homogeneity (1 is fully homogeneous)
        noadd = True to NOT add any higher-order states - assume
                that they just go to zero.  Be careful - this
                speeds up simulations, but may compromise accuracy!
        recovery = True to include T1 recovery in the Z0 state.

    OUTPUT:
        FpFmZ = updated F+, F- and Z states.

   """

    FpFmZ, EE = relax2(FpFmZ, TE/2., T1, T2)
    FpFmZ = grad(FpFmZ, noadd)
    FpFmZ = rf_B1_prime(FpFmZ, alpha, B1)
    FpFmZ = grad(FpFmZ, noadd)
    FpFmZ = np.dot(EE, FpFmZ)

    return FpFmZ



### Gradients of full FSE EPG function across T time points


def FSE_signal_prime_alpha_idx(angles_rad, TE, T1, T2, idx):
    """Gradient of EPG function at each time point w.r.t. RF pulse alpha_i"""

    T = len(angles_rad)
    zi = np.hstack((np.array([[1],[1],[0]]), np.zeros((3, T))))

    z_prime = np.zeros((T, 1))

    for i in range(T):
        alpha = angles_rad[i]
        if i < idx:
            zi = FSE_TE(zi, alpha, TE, T1, T2, noadd=True)
            z_prime[i] = 0
        elif i == idx:
            wi = FSE_TE_prime_alpha(zi, alpha, TE, T1, T2, noadd=True)
            z_prime[i] = wi[0,0]
        else:
            wi = FSE_TE(wi, alpha, TE, T1, T2, noadd=True, recovery=False)
            z_prime[i] = wi[0,0]

    return z_prime


def FSE_signal_prime_T1(angles_rad, TE, T1, T2):
    return FSE_signal_ex_prime_T1(np.pi/2, angles_rad, TE, T1, T2)

def FSE_signal_ex_prime_T1(angle_ex_rad, angles_rad, TE, T1, T2, B1=1.):
    """Gradient of EPG function at each time point w.r.t. T1"""
    
    T = len(angles_rad)

    try:
        B1 = B1[0]
    except:
        pass

    # since the grad doesn't depend on B1 inhomog, can just pre-scale flip angles
    angle_ex_rad = B1 * np.copy(angle_ex_rad)
    angles_rad = B1 * np.copy(angles_rad)
    
    zi = np.hstack((rf_ex(np.array([[0],[0],[1]]), angle_ex_rad), np.zeros((3, T))))
    z_prime = np.zeros((T, 1))
    
    for i in range(T):
        
        alpha = angles_rad[i]

        if i == 0:
            wi = np.zeros((3, T+1))
        else:
            wi = FSE_TE(wi, alpha, TE, T1, T2, noadd=True, recovery=False)
            
        wi += FSE_TE_prime1_T1(zi, alpha, TE, T1, T2, noadd=True)
        wi += FSE_TE_prime2_T1(zi, alpha, TE, T1, T2, noadd=True)

        zi = FSE_TE(zi, alpha, TE, T1, T2, noadd=True)
        z_prime[i] = wi[0,0]

    return z_prime


def FSE_signal_prime_T2(angles_rad, TE, T1, T2):
    return FSE_signal_ex_prime_T2(np.pi/2, angles_rad, TE, T1, T2)

def FSE_signal_ex_prime_T2(angle_ex_rad, angles_rad, TE, T1, T2, B1=1.):
    """Gradient of EPG function at each time point w.r.t. T2"""
    
    T = len(angles_rad)

    try:
        B1 = B1[0]
    except:
        pass

    # since the grad doesn't depend on B1 inhomog, can just pre-scale flip angles
    angle_ex_rad = B1 * np.copy(angle_ex_rad)
    angles_rad = B1 * np.copy(angles_rad)
    
    zi = np.hstack((rf_ex(np.array([[0],[0],[1]]), angle_ex_rad), np.zeros((3, T))))
    z_prime = np.zeros((T, 1))

    for i in range(T):
      
        alpha = angles_rad[i]

        if i == 0:
            wi = np.zeros((3, T+1))
        else:
            wi = FSE_TE(wi, alpha, TE, T1, T2, noadd=True, recovery=False)

        wi += FSE_TE_prime1_T2(zi, alpha, TE, T1, T2, noadd=True)
        wi += FSE_TE_prime2_T2(zi, alpha, TE, T1, T2, noadd=True)
        
        zi = FSE_TE(zi, alpha, TE, T1, T2, noadd=True)
        z_prime[i] = wi[0,0]

    return z_prime


def FSE_signal_ex_prime_B1(angle_ex_rad, angles_rad, TE, T1, T2, B1):
    """Gradient of EPG function at each time point w.r.t. B1 Homogeneity.
    Includes the excitation flip angle"""
    
    T = len(angles_rad)
    zi = np.hstack((np.array([[0],[0],[1]]), np.zeros((3, T+1))))

    z_prime = np.zeros((T, 1))

    wi = rf_ex_B1_prime(zi, angle_ex_rad, B1)
    zi = rf_ex(zi, angle_ex_rad * B1)

    for i in range(T):

        alpha = angles_rad[i]

        if i == 0:
            xi = FSE_TE(wi, alpha * B1, TE, T1, T2, noadd=True, recovery=False)
        else:
            xi = FSE_TE(wi, alpha * B1, TE, T1, T2, noadd=True)

        wi = FSE_TE_prime_B1(zi, alpha, TE, T1, T2, B1, noadd=True) + xi

        zi = FSE_TE(zi, alpha * B1, TE, T1, T2, noadd=True)

        z_prime[i] = wi[0,0]

    return z_prime



### Full FSE EPG function across T time points


def FSE_signal_ex(angle_ex_rad, angles_rad, TE, T1, T2, B1=1.):
    """Same as FSE_signal2_ex, but only returns Mxy"""
    return FSE_signal2_ex(angle_ex_rad, angles_rad, TE, T1, T2, B1)[0]

def FSE_signal(angles_rad, TE, T1, T2):
    """Same as FSE_signal2, but only returns Mxy"""

    return FSE_signal2(angles_rad, TE, T1, T2)[0]

def FSE_signal2(angles_rad, TE, T1, T2):
    """Same as FSE_signal2_ex, but assumes excitation pulse is 90 degrees"""

    return FSE_signal2_ex(np.pi/2., angles_rad, TE, T1, T2)


def FSE_signal2_ex(angle_ex_rad, angles_rad, TE, T1, T2, B1=1.):
    """Simulate Fast Spin-Echo CPMG sequence with specific flip angle train.
    Prior to the flip angle train, an excitation pulse of angle_ex_rad degrees
    is applied in the Y direction. The flip angle train is then applied in the X direction.

    INPUT:
        angles_rad = array of flip angles in radians equal to echo train length
        TE = echo time/spacing
        T1 = T1 value in seconds
        T2 = T2 value in seconds

    OUTPUT:
        Mxy = Transverse magnetization at each echo time
        Mz = Longitudinal magnetization at each echo time
        
    """

    T = len(angles_rad)
    Mxy = np.zeros((T,1))
    Mz = np.zeros((T,1))

    P = np.array([[0],[0],[1]]) # initially on Mz

    try:
        B1 = B1[0]
    except:
        pass

    # pre-scale by B1 homogeneity
    angle_ex_rad = B1 * np.copy(angle_ex_rad)
    angles_rad = B1 * np.copy(angles_rad)

    P = rf_ex(P, angle_ex_rad) # initial tip

    for i in range(T):
        alpha = angles_rad[i]
        P = FSE_TE(P, alpha, TE, T1, T2)

        Mxy[i] = P[0,0]
        Mz[i] = P[2,0]

    return Mxy, Mz



if __name__ == "__main__":
    import matplotlib.pyplot as plt

    T1 = 1000e-3
    T2 = 200e-3

    TE = 5e-3

    N = 100
    angles = 120 * np.ones((N,))
    angles_rad = angles * np.pi / 180.

    S = FSE_signal(angles_rad, TE, T1, T2)
    S2 = abs(S)
    plt.plot(TE*1000*np.arange(1, N+1), S2)
    plt.xlabel('time (ms)')
    plt.ylabel('signal')
    plt.title('T1 = %.2f ms, T2 = %.2f ms' % (T1 * 1000, T2 * 1000))
    plt.show()
    

